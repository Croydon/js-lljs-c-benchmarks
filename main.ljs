
extern window, document, setTimeout,
  Stats, console, Array, undefined, Image, isDown, Math, Date;

// let memcheck = require('memcheck');

let requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
})();

let stats;
let canvas = document.getElementById('canvas');
canvas.width = document.body.clientWidth / 2;
canvas.height = document.body.clientHeight / 2;

let ctx = canvas.getContext('2d');

// Sprites

let resourceCache = new Array(1000);
let readyCallbacks = [];

function loadResource(id, url) {
    if(resourceCache[id] === undefined) {
        let img = new Image();
        img.onload = function() {
            resourceCache[id] = img;

            if(isReady()) {
                readyCallbacks.forEach(function(func) {
                    func();
                });
                readyCallbacks = [];
            }
        };
        resourceCache[id] = false;
        img.src = url;
    }
}

function getResource(id) {
    return resourceCache[id];
}

function isReady() {
    let ready = true;
    for(let k in resourceCache) {
        if(!resourceCache[k]) {
            ready = false;
        }
    }
    return ready;
}

function onReady(func) {
    if(isReady()) {
        func();
    }
    else {
        readyCallbacks.push(func);
    }
}

// Util

struct Vec2d {
    float x, y;
}

struct Vec2di {
    int x, y;
}

// Sprites

struct Sprite {
    Vec2di offset, size;
    float speed;
    int img;
    int numFrames;
    float _index;
}

function updateSprite(Sprite* sprite, float dt) {
    sprite->_index += sprite->speed * dt;
}

function renderSprite(ctx, Sprite* sprite, int x, int y) {
    renderSpriteClipped(ctx, sprite, x, y, sprite->size.x, sprite->size.y);
}

function renderSpriteClipped(ctx,
                             Sprite* sprite,
                             int x, int y, 
                             int clipX, int clipY) {
    let Vec2di *offset = &sprite->offset;
    let Vec2di *size = &sprite->size;
    let img = getResource(sprite->img);

    // We manually reset _index so that it doesn't increase forever
    // and oveflow at some point
    if(sprite->_index > sprite->numFrames) {
        sprite->_index = 0;
    }

    let int frame = sprite->_index;

    ctx.save();
    ctx.translate(x, y);
    ctx.drawImage(getResource(sprite->img),
                  offset->x + frame * size->x, offset->y,
                  Math.min(size->x, clipX), Math.min(size->y, clipY),
                  0, 0,
                  Math.min(size->x, clipX), Math.min(size->y, clipY));
    ctx.restore();
}

// Entities

struct Entity {
    int type;
    Vec2d pos;
    Vec2di size;
    Sprite *sprite;
}
typedef Entity* EntityPtr;

function renderEntity(Entity *entity) {
    if(entity->sprite) {
        renderSprite(ctx, entity->sprite, entity->pos.x, entity->pos.y);
    }
}

function updateEntity(Entity *entity, float dt) {
    if(entity->type == ENTITY_PLAYER) {
        if(isDown('up')) {
            entity->pos.y = entity->pos.y - 100*dt;
        }

        if(isDown('down')) {
            entity->pos.y = entity->pos.y + 100*dt;
        }

        if(isDown('left')) {
            entity->pos.x = entity->pos.x - 100*dt;
        }

        if(isDown('right')) {
            entity->pos.x = entity->pos.x + 100*dt;
        }
    }

    if(entity->sprite) {
        updateSprite(entity->sprite, dt);
    }
}

function Entity* makeEntity(int type, Sprite *sprite) {
    let Entity *entity = new Entity();
    entity->type = type;
    entity->pos.x = (int)(Math.random() * canvas.width);
    entity->pos.y = (int)(Math.random() * canvas.height);
    entity->size.x = sprite->size.x;
    entity->size.y = sprite->size.y;
    entity->sprite = sprite;

    return entity;
}

// Cells

struct CellNode {
    Entity* entity;
    CellNode *next;
}
typedef CellNode* CellNodePtr;

struct Cells {
    Vec2di size, count;
    int _length;
    CellNodePtr *cache;
}

function Cells* makeCells(int w, int h, int numX, int numY) {
    let Cells *cells = new Cells();
    cells->size.x = w;
    cells->size.y = h;
    cells->count.x = numX;
    cells->count.y = numY;
    cells->_length = numX*numY;
    cells->cache = null;

    cellsClear(cells);
    return cells;
}

function cellsClear(Cells *cells) {
    if(cells->cache) {
        for(let int i=0; i<cells->_length; i++) {
            let CellNode *ptr = cells->cache[i];
            while(ptr) {
                let CellNode *old = ptr;
                ptr = ptr->next;
                delete old;
            }
        }
        delete cells->cache;
    }

    cells->cache = new CellNodePtr[cells->_length];
    for(let int i=0; i<cells->_length; i++) {
        cells->cache[i] = null;
    }
}

function cellsAdd(Cells *cells, Entity* entity) {
    let float x = entity->pos.x;
    let float y = entity->pos.y;
    let int cellSizeX = cells->size.x / cells->count.x;
    let int cellSizeY = cells->size.y / cells->count.y;

    if(x > 0 && y > 0 && x < cells->size.x && y < cells->size.y) {
        let int idx = (cells->count.x *
                       (int)(y / cellSizeY) +
                       (int)(x / cellSizeX));

        let CellNode *node = new CellNode();
        node->entity = entity;
        
        if(cells->cache[idx]) {
            node->next = cells->cache[idx];
        }
        else {
            node->next = null;
        }

        cells->cache[idx] = node;
    }
}

function CellNode* cellsGet(Cells *cells, x, y) {
    let int cellSizeX = cells->size.x / cells->count.x;
    let int cellSizeY = cells->size.y / cells->count.y;

    if(x > 0 && y > 0 && x < cells->size.x && y < cells->size.y) {
        let int idx = (cells->count.x *
                       (int)(y / cellSizeY) +
                       (int)(x / cellSizeX));
        return cells->cache[idx];
    }

    return null;
}

// Game

let int ENTITY_PLAYER = 1;
let int ENTITY_ENEMY = 2;

let int IMG_BOSSES = 1;

let numEntities = 3000;
let EntityPtr *objects = new EntityPtr[numEntities];
let Cells *cells = makeCells((int)(canvas.width), (int)(canvas.height), 6, 6);

let Sprite *playerSprite = new Sprite();
playerSprite->offset.x = 0;
playerSprite->offset.y = 395;
playerSprite->size.x = 80;
playerSprite->size.y = 35;
playerSprite->speed = 5.0;
playerSprite->img = IMG_BOSSES;
playerSprite->numFrames = 3;
playerSprite->_index = 0;

let Entity *playerEntity = makeEntity(ENTITY_PLAYER, playerSprite);
objects[0] = playerEntity;

for(let int i=1; i<numEntities; i++) {
    let Sprite *enemySprite = new Sprite();
    enemySprite->offset.x = 0;
    enemySprite->offset.y = 111;
    enemySprite->size.x = 240/6;
    enemySprite->size.y = 40;
    enemySprite->speed = 5.0;
    enemySprite->img = IMG_BOSSES;
    enemySprite->numFrames = 6;
    enemySprite->_index = 0;

    objects[i] = makeEntity(ENTITY_ENEMY, enemySprite);
}

function removeObject(entity) {
    for(let int i=0; i<numEntities; i++) {
        if(objects[i] == entity) {
            objects[i] = null;
        }
    }
}

function collides(x, y, r, b, x2, y2, r2, b2) {
    return !(r <= x2 || x > r2 ||
             b <= y2 || y > b2);
}

function _checkCollisions(Entity *entity, CellNode* node) {
    let Vec2d *pos = &entity->pos;
    let Vec2di *size = &entity->size;

    while(node) {
        if(node->entity != entity) {
            let Vec2d *pos2 = &node->entity->pos;
            let Vec2di *size2 = &node->entity->size;

            if(collides(pos->x, pos->y,
                        pos->x + size->x, pos->y + size->y,
                        pos2->x, pos2->y,
                        pos2->x + size2->x, pos2->y + size2->y)) {
                if(entity == playerEntity) {
                    removeObject(node->entity);
                }
            }
        }

        node = node->next;
    }
}

function checkCollisions() {
    for(let int i=0; i<numEntities; i++) {
        let Entity *ent = objects[i];

        if(ent) {
            _checkCollisions(ent, cellsGet(cells, ent->pos.x, ent->pos.y));
            _checkCollisions(ent, cellsGet(cells,
                                           ent->pos.x,
                                           ent->pos.y + ent->size.y));
            _checkCollisions(ent, cellsGet(cells,
                                           ent->pos.x + ent->size.x,
                                           ent->pos.y));
            _checkCollisions(ent, cellsGet(cells,
                                           ent->pos.x + ent->size.x,
                                           ent->pos.y + ent->size.y));
        }
    }
}

let float last = (float)(Date.now() / 1000);
function heartbeat() {
    stats.begin();
    let float now = (float)(Date.now() / 1000);

    checkCollisions();
    cellsClear(cells);

    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for(let int x=0; x<numEntities; x++) {
        if(objects[x]) {
            updateEntity(objects[x], now - last);
            renderEntity(objects[x]);

            cellsAdd(cells, objects[x]);
        }
    }

    stats.end();
    last = now;
    requestAnimFrame(heartbeat);
    //finish();
}

function finish() {
    for(let int x=0; x<numEntities; x++) {
        delete objects[x]->sprite;
        delete objects[x];
    }

    delete objects;

    cellsClear(cells);
    delete cells->cache;
    delete cells;

    //console.log(memcheck.report());
}

loadResource(IMG_BOSSES, 'resources/bosses.png');

window.addEventListener('load', function() {
    stats = new Stats();
    stats.setMode(1);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild(stats.domElement);

    onReady(heartbeat);
});

